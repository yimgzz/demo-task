# Demo task

[1. Разработка микросервиса](#development) \
[2. Разработка Dockerfile](#build) \
[3. Разработка Gitlab CI Pipeline](#ci) \
[4. Разработка Helm chart](#helm)

Результат выполнения предоставить в виде ссылки на публичный репозиторий github.com/gitlab.com/etc

<h2 id="development">Разработка микросервиса</h2>

С использованием любого языка программирования разработать микросервис, который:

1. инициализирует эндпойнт /write_message;

2. на созданном эндпойнте ожидает только POST запросы, для остальных возвращается http code 405 Method Not Allowed;

3. созданный эндпойнт обрабатывает json формата {"message": string };

4. в случае, если получен json неизвестного формата, клиенту возвращается http code 400 Bad Request;

5. если json валиден, то он записывается на диск по пути, заданному в переменной окружения `MESSAGES_PATH` и клиенту возвращается http code 201 Created.
Имя файла должно быть формата timestamp.json;

6. если при записи json на диск возникли ошибки, клиенту возвращается http code 500 Internal Server Error;

7. все запросы от клиентов, включая невалидные, логируются в stdout.

<h2 id="build">Разработка Dockerfile</h2>

Разработать Dockerfile для сборки микросервиса в docker образ

1. сервис не должен запускаться от пользователя root.

<h2 id="ci">Разработка Gitlab CI Pipeline</h2>

Разработать пайплайн .gitlab-ci.yml который реализует сборку docker образа в следующих случаях:

1. на push изменений исходного кода и\или Dockerfile в любую ветку, образа тегируется именем ветки;

2. при выпуске тега, который соответствует регулярному выражению semver https://semver.org/, в этом случае образ тегируется именем тега.

<h2 id="helm">Разработка Helm chart</h2>

Helm chart содержит следующие шаблоны для деплоя:

1. StatefulSet

-  в качестве image используется образ разработанного микросервиса.
image.name, image.tag и image.pullPolicy образа может кастомизироваться пользователем;

- реализовать настройку Persistence Volume Claim Template по флагу persistence.enabled=true;

-  если persistence.enabled=false, создается volume формата emptyDir;

-  реализовать volumeMount по пути, куда микросервис будет записывать json c использованием volume, который создан в предыдущих пунктах;

-  пользователь может кастомизировать значение пути, которое передается в переменную `MESSAGES_PATH` и volumeMount соответственно;

-  реализовать securityContext для пользователя, под которым запускается сервис.

2. Service type ClusterIP

3. Опционально: Ingress и\или HTTPRoute

-  если принято решение реализовать эти сущности, создание каждой из них должно управляться по флагу ingress.enabled и httpRoute.enabled соответственно.